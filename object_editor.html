<!DOCTYPE html>
<html lang="en">
    <head>
        <title>OSMEX3D Object editor</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

        <style>
            body {
                font-family: Monospace;
                background-color: #f0f0f0;
                margin: 0px;
                overflow: hidden;
            }
        </style>
    </head>
    <body>

        <script src="threejs/three.js"></script>

        <script src="scripts/ObjectScene.js"></script>
        <script src="scripts/InterfaceScene.js"></script>
        <script src="scripts/GridGeometry.js"></script>
        <script src="scripts/CameraController.js"></script>
        <script src="scripts/Block.js"></script>
        <script src="scripts/Cube.js"></script>
        <script src="scripts/ScaleCube.js"></script>
        <script src="scripts/Arrow.js"></script>
        <script src="scripts/SizerArrow.js"></script>
        <script src="scripts/SizerGizmo.js"></script>
        <script src="scripts/MovingGizmo.js"></script>
        <script src="scripts/MovingArrow.js"></script>
        <script src="scripts/Torus.js"></script>
        <script src="scripts/RotationTorus.js"></script>
        <script src="scripts/RotationGizmoOverlay.js"></script>
        
        <script src="scripts/RotationGizmo.js"></script>

        <script>
            
            var SCREEN_WIDTH = window.innerWidth;
            var SCREEN_HEIGHT = window.innerHeight;
            var SCREEN_FOV = 45;

            var container;

            var renderer;
            var camera, cameraController, projector;
            var objectScene, interfaceScene;

            var mouse = new THREE.Vector2(0, 0);
			
            var PICKED, SELECTED, DRAGGING, SIZING, ROTATING, SCALING, MOVING;
            var offsetVector = new THREE.Vector3();
            
            var groundGrid;
			
            var sizerGizmo, rotationGizmo, movingGizmo, sizerPlane;
            
            var arrowMode = false;
            
            var ROTATION_VECTOR, SCALING_VECTOR;
            
            function setArrowsType() {
                arrowMode = document.getElementById('arrowMode').checked;
            }

            init();
            animate();

            function init() {
                
                container = document.createElement( 'div' );
                document.body.appendChild( container );
                
                var info = document.createElement('div');
                info.style.position = 'absolute';
		info.style.top = '10px';
		info.style.width = '100%';
		info.style.textAlign = 'center';
                info.innerHTML += '<br/>Scale arrows: <input id="arrowMode" onchange="setArrowsType()" type="checkbox" /> ';
                document.body.appendChild( info );
                
                renderer = new THREE.WebGLRenderer( { antialias: true } );

                camera = new THREE.PerspectiveCamera( SCREEN_FOV, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 1000 );
                camera.rotation.x -= Math.PI / 4;
                camera.position.z = 100;
                camera.position.y = 100;
				
                cameraController = new OSMEX.CameraController( camera );
                cameraController.userZoomSpeed = 2.0;
                //cameraController.addEventListener( 'change', render );
				
                objectScene = new OSMEX.ObjectScene();
                interfaceScene = new OSMEX.InterfaceScene(camera);

                objectScene.fog = new THREE.Fog( 0xffffff, 1, 1500 );
                objectScene.fog.color.setHSV( 0.6, 0.05, 1 );
                interfaceScene.fog = objectScene.fog;

                objectScene.add( new THREE.AmbientLight( 0x3f3f3f ) );
                interfaceScene.add( new THREE.AmbientLight( 0x3f3f3f ) );
				
                var objectLight = new THREE.DirectionalLight( 0xffffff);
                objectLight.position = camera.position;
                objectScene.add( objectLight );
				
                var interfaceLight = new THREE.DirectionalLight( 0xffffff);
                interfaceLight.position = camera.position;
                interfaceScene.add( interfaceLight );
				
                // GROUND
                var groundMaterial = new THREE.MeshBasicMaterial( { wireframe: true, color: 0x000000 } );
                groundMaterial.side = THREE.DoubleSide;
                var groundGeometry = new OSMEX.GridGeometry( 100, 100, 20, 20 );
                groundGrid = new THREE.Mesh( groundGeometry, groundMaterial );
                objectScene.add( groundGrid );        
                
                var blockGeometry = new THREE.CubeGeometry( 1, 1, 1 );
                var blockMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff, shading: THREE.SmoothShading } );//new THREE.MeshBasicMaterial( { color: 0xffffff } );//vertexColors: THREE.FaceColors } );
                var cubeBlock = new OSMEX.Block( blockGeometry, blockMaterial );
                cubeBlock.scale = new THREE.Vector3(10.0, 10.0, 10.0);
                objectScene.add( cubeBlock );	
				
                sizerGizmo = new OSMEX.SizerGizmo();
                interfaceScene.add(sizerGizmo);
                
                rotationGizmo = new OSMEX.RotationGizmo();
                interfaceScene.add(rotationGizmo);
                
                movingGizmo = new OSMEX.MovingGizmo();
                interfaceScene.add(movingGizmo);
                
   
                sizerPlane = new THREE.Plane();
						
                projector = new THREE.Projector();	

                // RENDERER

                renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
                renderer.setClearColor( objectScene.fog.color, 1 );
                renderer.autoClear = false;

                container.appendChild( renderer.domElement );
				
                document.addEventListener( 'mousemove', onDocumentMouseMove, false );
                document.addEventListener( 'mousedown', onDocumentMouseDown, false );
                document.addEventListener( 'mouseup', onDocumentMouseUp, false );
                window.addEventListener( 'resize', onWindowResize, false );
            }
			
            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );
            }
            
            function getPickedObject() {
                
                function getFirstSuitableObject(raycaster, objects, recursive) {
                    
                    var intersects = raycaster.intersectObjects( objects, recursive );
                    

                    if ( intersects.length > 0 ) {

                        for( i = 0; i < intersects.length; i++ ) {
                            
                            var intersector = intersects[i];
                            if (intersector.object.parent.name === "RotationGizmoOverlay") return null;

                            if ( intersector.object.pickable && intersector.object.visible ) {
                                return intersector.object;
                            }
                        }
                    }

                    return null;
                } 
                
                var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
                projector.unprojectVector( vector, camera );
				
                var raycaster = new THREE.Raycaster( camera.position, vector.subSelf( camera.position ).normalize() );
                
                var pickedObject = getFirstSuitableObject(raycaster, interfaceScene.children, true);
                
                if (pickedObject === null) {
                    
                    pickedObject = getFirstSuitableObject(raycaster, objectScene.children);
                }
                
                return pickedObject;
            }

            function onDocumentMouseMove( event ) {
                
                event.preventDefault();

                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                
                if ( DRAGGING ) {
                    
                    var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
	            projector.unprojectVector( vector, camera );
                    var raycaster = new THREE.Raycaster( camera.position, vector.subSelf( camera.position ).normalize() );
                    var intersects = raycaster.intersectObject(groundGrid);
                 
                    if ( intersects.length > 0 ) {
                        
                        DRAGGING.position.copy(intersects[0].point.subSelf( offsetVector ));
                    }
                }
                else if ( SIZING ) {
                    
                    var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
                    projector.unprojectVector( vector, camera );
                    var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );
                    var intersectPoint = ray.intersectPlane(sizerPlane);

                    if (intersectPoint !== undefined) {
                        
                        intersectPoint.subSelf(SIZING.matrixWorld.getPosition());
                        intersectPoint.multiplyScalar(1.0 / SIZING.parent.scale.x); // to compensate changing scale on changing distance
                         //console.log (intersectPoint);
                        var len = SIZING.dir.dot(intersectPoint);
                        // TODO: workaround should be reimplemented
                        if (Math.abs(SIZING.len - len) < (SIZING.maxLength - SIZING.minLength)) {
                            
                            SIZING.setLength(len);
                        }
                    }
                }
                else if ( MOVING ) {
                    
                    var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
	            projector.unprojectVector( vector, camera );
                    var raycaster = new THREE.Raycaster( camera.position, vector.subSelf( camera.position ).normalize() );
                    var intersects = raycaster.intersectObject(groundGrid);
                 
                    if ( intersects.length > 0 ) {

                        var position = intersects[0].point.subSelf( offsetVector );
                        MOVING.setPosition (position);
                    }
                }
                else if ( SCALING ) {
                    var mouseX = (mouse.x* SCREEN_WIDTH/2)/10;
                        
                    var sizingPos = projector.projectVector( SCALING.matrixWorld.getPosition().clone(), camera );
                    sizingPos.x = (sizingPos.x * SCREEN_WIDTH/2)/10;
                    var len = mouseX - sizingPos.x;

                    SCALING.setScale(len);

                    
                }
                else if ( ROTATING ) {
                    
                    var mouseX = (mouse.x* SCREEN_WIDTH/2) + SCREEN_WIDTH/2;
                    var mouseY = -(mouse.y* SCREEN_HEIGHT/2)+ SCREEN_HEIGHT/2;
                    var vector = projector.projectVector( ROTATING.matrixWorld.getPosition().clone(), camera );

                    vector.x = ( vector.x * SCREEN_WIDTH/2 ) + SCREEN_WIDTH/2;
                    vector.y = - ( vector.y * SCREEN_HEIGHT/2 ) + SCREEN_HEIGHT/2;                 
                    var currentVector = new THREE.Vector2(-(vector.x-mouseX), vector.y-mouseY).normalize();

                     ROTATING.setAngle(ROTATION_VECTOR, currentVector);
                       
                }
                else {
                    
                    var pickedObject = getPickedObject();

                    if ( PICKED != pickedObject ) {

                        if ( PICKED ) {
                            PICKED.material.emissive.setHex( PICKED.oldEmissive );
                        }

                        PICKED = pickedObject;

                        if ( PICKED ) {
                            
                            PICKED.oldEmissive = PICKED.material.emissive.getHex();
                            PICKED.material.emissive.setHex( 0xff0000 );
                        }
                    }
                }
            }
			
            function onDocumentMouseDown( event ) {
                
                event.preventDefault();
				
                if (event.button == 0) {
                                     
                    if ( PICKED ) {
                        
                        var pickRef = (PICKED.pickRef !== undefined ? PICKED.pickRef : PICKED);
                        
                        if ( pickRef instanceof OSMEX.Block ) {

                            SELECTED = pickRef;
                            DRAGGING = pickRef;

                            var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
                            projector.unprojectVector( vector, camera );
                            var raycaster = new THREE.Raycaster( camera.position, vector.subSelf( camera.position ).normalize() );
                            var intersects = raycaster.intersectObject( groundGrid );
                            offsetVector.copy( intersects[ 0 ].point ).subSelf( DRAGGING.position );
                        }
                        else if ( pickRef instanceof OSMEX.SizerArrow ) {
                            
                            SIZING = pickRef;
                            var sizingPos = SIZING.matrixWorld.getPosition();
                            var cameraDir = camera.position.clone().subSelf(sizingPos).normalize();
                            var rightDir = cameraDir.clone().crossSelf(SIZING.dir);  
                            var forwardDir = SIZING.dir.clone().crossSelf(rightDir);
                            sizerPlane.setFromNormalAndCoplanarPoint(forwardDir, sizingPos);
                            // TODO: situation when user is doing camera rotation while LMK pressed should be considered!
                        }
                        else if ( pickRef instanceof OSMEX.MovingArrow ) {
                            
                            MOVING = pickRef;
                            var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
                            projector.unprojectVector( vector, camera );
                            var raycaster = new THREE.Raycaster( camera.position, vector.subSelf( camera.position ).normalize() );
                            var intersects = raycaster.intersectObject( groundGrid );
                            offsetVector.copy( intersects[ 0 ].point ).subSelf( MOVING.position );                 
                        }
                        else if ( pickRef instanceof OSMEX.ScaleCube ) {
                            
                            SCALING = pickRef;
                                                       
                        }
                        else if ( pickRef instanceof OSMEX.RotationTorus ) {
                            ROTATING = pickRef;
                            
                            var mouseX = (mouse.x* SCREEN_WIDTH/2) + SCREEN_WIDTH/2;
                            var mouseY = -(mouse.y* SCREEN_HEIGHT/2)+ SCREEN_HEIGHT/2;
                            var vector = projector.projectVector( ROTATING.matrixWorld.getPosition().clone(), camera );

                            vector.x = ( vector.x * SCREEN_WIDTH/2 ) + SCREEN_WIDTH/2;
                            vector.y = - ( vector.y * SCREEN_HEIGHT/2 ) + SCREEN_HEIGHT/2;
                            ROTATION_VECTOR = new THREE.Vector2(-(vector.x-mouseX), vector.y-mouseY).normalize();
                           
                        }
                        else {
                            
                            SELECTED = null;
                        }
                    }
                    else {
                        
                        SELECTED = null;
                    }
                    if(arrowMode) sizerGizmo.setTarget(SELECTED); else movingGizmo.setTarget(SELECTED);
                    rotationGizmo.setTarget(SELECTED);
                }

            }
            
            function onDocumentMouseUp( event ) {
                
                event.preventDefault();
				
                if (event.button == 0) {
                    
                    if (SIZING) SIZING.restoreDefaultLength();
                    if (SCALING) SCALING.restoreDefaultScale();
                    
                    DRAGGING = null;
                    SIZING = null;
                    SCALING = null;
                    ROTATING = null;
                    MOVING = null;
                    ROTATION_VECTOR = null;
                }
            }

            function animate() {
                
                requestAnimationFrame( animate );
                
                update();
                render();
            }
            
            function update() {
                
                cameraController.update();
                rotationGizmo.update(camera);
                sizerGizmo.update();
                movingGizmo.update();
            } 
			
            function render() {
                
                renderer.clear();
                renderer.render( objectScene, camera );
                
                renderer.clear(false, true, false); // clear only Depth
                renderer.render( interfaceScene, camera );
            }

        </script>

    </body>
</html>
